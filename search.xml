<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>怎么让趋势性和周期性以及节假日这些玩意有意义</title>
      <link href="/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/"/>
      <url>/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="导入和线索"><a href="#导入和线索" class="headerlink" title="导入和线索"></a>导入和线索</h1><h3 id="已知部分的解释"><a href="#已知部分的解释" class="headerlink" title="已知部分的解释"></a><strong>已知部分的解释</strong></h3><p>这里主要是结合课程内容来分析商店销售量的</p><p>(如有疏漏请指出)</p><h4 id="一般路过导包"><a href="#一般路过导包" class="headerlink" title="一般路过导包"></a><strong>一般路过导包</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> warnings <span class="keyword">import</span> simplefilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.deterministic <span class="keyword">import</span> CalendarFourier, DeterministicProcess</span><br><span class="line"><span class="comment">#上面的进行傅里叶特征</span></span><br><span class="line">simplefilter(<span class="string">&quot;ignore&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="绘画设置的解释"><a href="#绘画设置的解释" class="headerlink" title="绘画设置的解释"></a><strong>绘画设置的解释</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plt.style.use(&quot;seaborn-whitegrid&quot;)</span><br><span class="line">plt.rc(&quot;figure&quot;, autolayout=True, figsize=(11, 5))</span><br><span class="line">plt.rc(</span><br><span class="line">    &quot;axes&quot;,</span><br><span class="line">    labelweight=&quot;bold&quot;,</span><br><span class="line">    labelsize=&quot;large&quot;,</span><br><span class="line">    titleweight=&quot;bold&quot;,</span><br><span class="line">    titlesize=16,</span><br><span class="line">    titlepad=10,</span><br><span class="line">)</span><br><span class="line">plot_params = dict(</span><br><span class="line">    color=&quot;0.75&quot;,</span><br><span class="line">    style=&quot;.-&quot;,</span><br><span class="line">    markeredgecolor=&quot;0.25&quot;,</span><br><span class="line">    markerfacecolor=&quot;0.25&quot;,</span><br><span class="line">    legend=False,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>rc中的是设置标题参数，dict是设置线的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">seasonal_plot</span>(<span class="params">X, y, period, freq, ax=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        _, ax = plt.subplots()</span><br><span class="line">    palette = sns.color_palette(<span class="string">&quot;husl&quot;</span>, n_colors=X[period].nunique(),)</span><br><span class="line">    ax = sns.lineplot(</span><br><span class="line">        x=freq,</span><br><span class="line">        y=y,</span><br><span class="line">        hue=period,</span><br><span class="line">        data=X,</span><br><span class="line">        ci=<span class="literal">False</span>,</span><br><span class="line">        ax=ax,</span><br><span class="line">        palette=palette,</span><br><span class="line">        legend=<span class="literal">False</span>,</span><br><span class="line">    )</span><br><span class="line">    ax.set_title(<span class="string">f&quot;Seasonal Plot (<span class="subst">&#123;period&#125;</span>/<span class="subst">&#123;freq&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line, name <span class="keyword">in</span> <span class="built_in">zip</span>(ax.lines, X[period].unique()):</span><br><span class="line">        y_ = line.get_ydata()[-<span class="number">1</span>]</span><br><span class="line">        ax.annotate(</span><br><span class="line">            name,</span><br><span class="line">            xy=(<span class="number">1</span>, y_),</span><br><span class="line">            xytext=(<span class="number">6</span>, <span class="number">0</span>),</span><br><span class="line">            color=line.get_color(),</span><br><span class="line">            xycoords=ax.get_yaxis_transform(),</span><br><span class="line">            textcoords=<span class="string">&quot;offset points&quot;</span>,</span><br><span class="line">            size=<span class="number">14</span>,</span><br><span class="line">            va=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如名，这是季节绘画函数</p><p>ax是返回的控制图表的对象,可以控制表的位置，标题，表的线和样式。在subplot中返回一个subplot对象，其中包括其中多个ax对象。放回对象根据有几个图和图的排列方式组织成.</p><h4 id="利用趋势性来解决这个问题看看"><a href="#利用趋势性来解决这个问题看看" class="headerlink" title="利用趋势性来解决这个问题看看"></a>利用趋势性来解决这个问题看看</h4><p>要做的是将其变成假人，然后拟合就行了，对吗。但是我拒绝，我直接采用我的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>没弄懂的一坨东西</p><ul><li>另外一种就是周期性表，我是不理解这玩意为什么有效。但可以通过看他的线大概符合上面周期性</li><li>在AR模型基本都是围绕平稳性来的，为什么这里会强调中设计的趋势和周期性。</li><li>另一个问题是傅里叶特征，好像就是通过三角函数来模拟周期性，然后利用得到的每个三角函数的值。</li></ul><p><img src="/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240108170440882.png" alt="image-20240108170440882"></p><p>然后利用每个周期性过程(即三角函数在这点的值)来进行线性拟合，这样子的话，我是不是也能在AR甚至其他的加权实现这点。</p><p>但我要先弄懂自回归这回事</p><h1 id="对时间序列的详细讨论"><a href="#对时间序列的详细讨论" class="headerlink" title="对时间序列的详细讨论"></a>对时间序列的详细讨论</h1><h3 id="差分方程的讨论"><a href="#差分方程的讨论" class="headerlink" title="差分方程的讨论"></a>差分方程的讨论</h3><p>为什么要讨论差分方程，你应该还记得定义:时间序列分析是研究过去的变化对现在的影响。而微分方程的基本形式如下</p><p>![](D:\blog\myblog\source_posts\怎么让趋势性和周期性以及节假日这些玩意有意义\屏幕截图 2024-01-08 201052.png)</p><p>T表示第i长度上T的值，可以看出来它们事实上很像对吗，事实上时间序列(如果他真的是时间序列)的话，他可以用时间序列来表示。举个例子:</p><h3 id="对平稳性，自协相关性，遍历性的讨论"><a href="#对平稳性，自协相关性，遍历性的讨论" class="headerlink" title="对平稳性，自协相关性，遍历性的讨论"></a>对平稳性，自协相关性，遍历性的讨论</h3><h5 id="期望和方差"><a href="#期望和方差" class="headerlink" title="期望和方差:"></a>期望和方差:</h5><p>很容易理解期望就是指将数组加起来求均值，而在概率论里面，期望是对概率分布函数的样本的求解。但是这也引来了一个问题，你怎么知道这是平均函数。（我想知道对于那些离散的函数，高斯过程还适用吗)</p><p>对于高斯白噪声(可以先理解为期望为0的正态分布)</p><p><img src="/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240109123219283.png" alt="image-20240109123219283"></p><p>他的期望值就是0，这也被称为无条件期望。为什么说是无条件呢，因为我们用的值是从中取出的部分值，只有当其值的数目接近于正无穷的时候，才会百分百接近这个概率。</p><p>对于其方差的概率分布，则为</p><p><img src="/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240109123552244.png" alt="image-20240109123552244"></p><p>比如高斯函数的方差则为</p><p><img src="/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240109123736357.png" alt="image-20240109123736357"></p><p>也就是正整数的方差，为什么要讨论这些，因为我想知道这些玩意有什么意义。</p><h5 id="自协方差"><a href="#自协方差" class="headerlink" title="自协方差"></a>自协方差</h5><p>自协方差可以表示为我们得到的时间序列的每一项和前n项的比较，</p><p><img src="/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240109124056542.png" alt="image-20240109124056542"></p><p>对于高斯分布来讲，自协方差的值如果n&#x3D;0，则自协方差则为方差值。对于其它的方程也是这样。但如果n不等于0又会怎么样呢。我们知道，对于两个概率分布不相等的分布，它们相乘的期望等于它们期望的值相乘。也就是说高斯分布的值为0.</p><p>但这样又有一些循环论证的感觉，让我们看看书是怎么说的:</p><p><img src="/2024/01/08/%E6%80%8E%E4%B9%88%E8%AE%A9%E8%B6%8B%E5%8A%BF%E6%80%A7%E5%92%8C%E5%91%A8%E6%9C%9F%E6%80%A7%E4%BB%A5%E5%8F%8A%E8%8A%82%E5%81%87%E6%97%A5%E8%BF%99%E4%BA%9B%E7%8E%A9%E6%84%8F%E6%9C%89%E6%84%8F%E4%B9%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240109124810769.png" alt="image-20240109124810769"></p><p>最后的做法和上面差不多，但还是有些循环论证的感觉。我们知道协方差系数用来估计相关性，但上面那东西的计算反而假定它们之间的分布，没有任何相关性。直接按期望计算的方法，也就在高斯分布的情况能用了，其它的还是老老实实一个一个算过去吧。</p><h5 id="平稳性和遍历性："><a href="#平稳性和遍历性：" class="headerlink" title="平稳性和遍历性："></a>平稳性和遍历性：</h5><p>平稳性分为弱平稳性和强平稳性，弱平稳性是满足协方差和均值只与滞后几段有关，而与t位于第几阶无关。对于具有弱平稳性的，Yt和Yt+j序列的平稳性和Yt-j和Yt的平稳性的是一致的。因为可以利用换元法，让Yt &#x3D; Yt-j，然后就一致了。</p><p>而对于强平稳性，则是其联合分布，都有只随着j而变化的特性。符合弱平稳性的。不一定符合强平稳性,符合强平稳性的，也不一定符合弱平稳性。但对于只有二阶矩的符合强平稳性的分布，一定有协方差平稳性，也就是弱平稳性。我们可以用高数的例子来理解。</p><p>(这里解释一下矩阶不存在的情况，比如对于柯西分布,其概率密度函数为1&#x2F;(1+t的平方)*pi，这玩意在两端的积分是不收敛的.这里的详细讨论请移到偏度章节)</p><p>遍历性可以这么理解，就像拿外卖的时候，如果你的外卖能尽量快的让你确定这是你的，那么我们说这玩意遍历性越好。那么对于分布来讲，因为我们得到的是局部的分布，不能代表总体分布。而遍历性要求的是当样本量增加时，尽可能快的接近分布概率，那么称其为二阶矩遍历</p><p>如果对于自协方差，当n变化时，如果足够快的接近一个值，那么称呼其为协方差遍历</p><p>为了区分平稳性和遍历性，我们可以想象这么一个函数，它由一个高斯函数和一个均值为0，方差为r2的函数构成</p><p>那么它的均值为0，方差为r2+E2(高斯分布的方差)，协方差为r2</p><p>但从无线时间的角度看，其均值会收敛于那个方差为r2的函数</p><h5 id="ARMA模型的各种性质"><a href="#ARMA模型的各种性质" class="headerlink" title="ARMA模型的各种性质"></a>ARMA模型的各种性质</h5><h6 id="这是MA模型"><a href="#这是MA模型" class="headerlink" title="这是MA模型"></a>这是MA模型</h6><h6 id="这是AR模型"><a href="#这是AR模型" class="headerlink" title="这是AR模型"></a>这是AR模型</h6><h3 id="偏度–对各种矩的讨论"><a href="#偏度–对各种矩的讨论" class="headerlink" title="偏度–对各种矩的讨论"></a>偏度–对各种矩的讨论</h3>]]></content>
      
      
      <categories>
          
          <category> -技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对ICR的数据分析</title>
      <link href="/2024/01/05/%E5%AF%B9ICR%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/05/%E5%AF%B9ICR%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="？背景知识"><a href="#？背景知识" class="headerlink" title="？背景知识"></a>？背景知识</h1><ul><li><p><input disabled type="checkbox"> </p><h4 id="我大概知道那些图怎么画了，问题是我要怎么找到新奇的观点，让这一切都有效。我已经分析了大多数数据的分布，现在我想探索性别特诊和知道大多数变量有什么值"><a href="#我大概知道那些图怎么画了，问题是我要怎么找到新奇的观点，让这一切都有效。我已经分析了大多数数据的分布，现在我想探索性别特诊和知道大多数变量有什么值" class="headerlink" title="我大概知道那些图怎么画了，问题是我要怎么找到新奇的观点，让这一切都有效。我已经分析了大多数数据的分布，现在我想探索性别特诊和知道大多数变量有什么值?"></a>我大概知道那些图怎么画了，问题是我要怎么找到新奇的观点，让这一切都有效。我已经分析了大多数数据的分布，现在我想探索性别特诊和知道大多数变量有什么值?</h4></li><li><p><input disabled type="checkbox"> </p><h4 id="我已经知道，堆叠这个过程大概的内容，无非是多个函数混在一起，把不同的部分把好的部分整起来，但我想知道这是否属实。"><a href="#我已经知道，堆叠这个过程大概的内容，无非是多个函数混在一起，把不同的部分把好的部分整起来，但我想知道这是否属实。" class="headerlink" title="我已经知道，堆叠这个过程大概的内容，无非是多个函数混在一起，把不同的部分把好的部分整起来，但我想知道这是否属实。"></a>我已经知道，堆叠这个过程大概的内容，无非是多个函数混在一起，把不同的部分把好的部分整起来，但我想知道这是否属实。</h4></li><li><p><input disabled type="checkbox"> </p><h4 id="还有分析，我要按书上的方法分析一次，并判断这是否有效"><a href="#还有分析，我要按书上的方法分析一次，并判断这是否有效" class="headerlink" title="还有分析，我要按书上的方法分析一次，并判断这是否有效"></a>还有分析，我要按书上的方法分析一次，并判断这是否有效</h4></li><li><p><input checked disabled type="checkbox"> </p><h4 id="到目前为止，其实我一直不觉得数据和目标数据的预测有什么相关性？"><a href="#到目前为止，其实我一直不觉得数据和目标数据的预测有什么相关性？" class="headerlink" title="到目前为止，其实我一直不觉得数据和目标数据的预测有什么相关性？"></a>到目前为止，其实我一直不觉得数据和目标数据的预测有什么相关性？</h4><h5 id="搜索知乎平台"><a href="#搜索知乎平台" class="headerlink" title="搜索知乎平台"></a>搜索知乎平台</h5><p>获得一本书，还有一个幽默的解释，大概是这样的分析。哈哈哈，以后我有问题肯定上知乎看看</p><p>就好像弄一个飞踢，一开始不是很熟悉。。。hhh</p><p>通过这本书，我学到了一个叫做模型拟合假设的东西。就是说，在只是完全随机的情况，根本无法来提升，拟合假设和验证假设的正确率。关于验证假设和拟合假设可以用这个词来概况，我挑战大树守卫获得的技能，比如躲横扫，能在多大程度上用在黑夜骑士上。</p><p>什么是拟合假设：就是拟合训练数据的正确率</p><p>什么是验证假设：顾名思义，测试数据的正确率</p><p>为什么可以在这种程度上提升</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>神奇的正态回归</title>
      <link href="/2023/12/31/%E7%A5%9E%E5%A5%87%E7%9A%84%E6%AD%A3%E6%80%81%E5%9B%9E%E5%BD%92/"/>
      <url>/2023/12/31/%E7%A5%9E%E5%A5%87%E7%9A%84%E6%AD%A3%E6%80%81%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>Q正态分布是什么</p><p>从说明上，正态分布是符合以下规则<br>$$<br>F(X)&#x3D;1&#x2F;sqrt(2PI*pow(q,2))*pow(e,-(x-u)2&#x2F;2q2)<br>$$<br>这是它的概率密度函数，总的来说，就像其它分布一样，它有着一些很方便的计算公式。篇幅和文章重点原因，我们先不讨论这两个公式是怎么证明的</p><p>这两个公式，你只需要记住这两个公式分别是上述的概率密度函数乘以X和X的平方，我们即可得到其均值和方差。或者现在你也可以简单地将其记忆为，这玩意计算起来很方便</p><h3 id="最大似然估计和最小二乘法"><a href="#最大似然估计和最小二乘法" class="headerlink" title="最大似然估计和最小二乘法"></a>最大似然估计和最小二乘法</h3><p>最大似然估计的核心思想如下，我们想要通过我们猜测的样本后面的整体是什么分布，我们假设我们抽出的东西是符合某类分布的，任何调整那两种分布的参数，让其最大程度符合抽取样本。（这种方式往往是求最值）</p><p>而最小二乘法，同样是假定他符合某种函数，只是当变量符合正态分布时，白噪音会抵消掉。这时候可以用最最小二乘分布来替代结果。</p><p>这种白噪音是怎么抵消掉的，另一个问题是，这在偏最小二乘也同样适用吗?</p><p>在很多机器学习的算法中，就是拿最小二乘估计来当罚函数的，所以会要求数据符合最小二乘估计</p><p>等会我再来解释什么是lasso或者E-net</p>]]></content>
      
      
      <categories>
          
          <category> -理论笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -正态分布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于羊群算法的研究</title>
      <link href="/2023/12/09/%E5%85%B3%E4%BA%8E%E7%BE%8A%E7%BE%A4%E7%AE%97%E6%B3%95%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>/2023/12/09/%E5%85%B3%E4%BA%8E%E7%BE%8A%E7%BE%A4%E7%AE%97%E6%B3%95%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>时间序列的一系列特性</title>
      <link href="/2023/11/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E7%89%B9%E6%80%A7/"/>
      <url>/2023/11/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="特性集"><a href="#特性集" class="headerlink" title="特性集"></a>特性集</h1><h3 id="趋势性："><a href="#趋势性：" class="headerlink" title="趋势性："></a>趋势性：</h3><p>顾名思义，就是可以沿着一段函数发展的性质。这听上去很像拟合(在大的层面上这没错)，像是总体上升，这都是趋势性。一种简单调用趋势性的方法是</p><h5 id="移动平均"><a href="#移动平均" class="headerlink" title="移动平均"></a>移动平均</h5><p>什么是移动平均呢，这和趋势性又有什么关系。移动平均是趋势性的一种表达形式，是将一定范围内的数据用一个平均值调度</p><p><img src="/2023/11/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E7%89%B9%E6%80%A7/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20231130001151706.png" alt="image-20231130001151706"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax = sns.regplot(x=<span class="string">&#x27;Lag_1&#x27;</span>, y=<span class="string">&#x27;NumVehicles&#x27;</span>, data=df, ci=<span class="literal">None</span>, scatter_kws=<span class="built_in">dict</span>(color=<span class="string">&#x27;0.25&#x27;</span>))</span><br><span class="line">ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;Lag Plot of Hardcover Sales&#x27;</span>);</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样子会拟合一个线性函数，然后你就能看到。。。他们之间的。。有这个趋势，我想知道这种趋势有什么用</p><h3 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a>周期性</h3><p>还有一个称为季节性，就是会随着周，月日的趋势。我没有明确我所学的一切的意义。有点生搬硬造了。我该怎么让每天的周期性，</p><p><img src="/2023/11/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E7%89%B9%E6%80%A7/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20231130001552053.png" alt="image-20231130001552053"></p><p>![image-20240108153633144](C:\Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240108153633144.png</p>]]></content>
      
      
      <categories>
          
          <category> -技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习的remake</title>
      <link href="/2023/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84remake/"/>
      <url>/2023/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84remake/</url>
      
        <content type="html"><![CDATA[<h1 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h1><p>(今天也成功幻想自己做了5个引体向上)</p><p>说是会机器学习，其实我也只是会调用函数，对于数据构造一窍不通。之前我接触过一个博客，讨论了基于数据探索性分析的数据构造。怎么说呢，他将准确率达到了过空准确率的80%。而我的结果只有0%,没错是零。为什么?</p><p>基本的数据如下</p><p>[Here](<a href="https://www.kaggle.com/competitions/spaceship-titanic/code?competitionId=34377&sortBy=voteCount">Spaceship Titanic | Kaggle</a>)</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="怎么探索的"><a href="#怎么探索的" class="headerlink" title="怎么探索的"></a>怎么探索的</h3><p>我只是拿到原始数据而已，真糟糕。我该怎么处理他们。</p><h4 id="来自未来的我："><a href="#来自未来的我：" class="headerlink" title="来自未来的我："></a>来自未来的我：</h4><p>基本来说要查看他们的缺失值，值的类型，值的大小，以及探索重复值的程度。这样子有助于对他们的组成有些基础了解</p><h4 id="过去的我"><a href="#过去的我" class="headerlink" title="过去的我:"></a>过去的我:</h4><p>我遇到了一个问题，而且不知道里面的函数有什么用。现在我是在做什么呢。对，先把库导入吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Core</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;darkgrid&#x27;</span>, font_scale=<span class="number">1.4</span>)</span><br><span class="line"><span class="keyword">from</span> imblearn.over_sampling <span class="keyword">import</span> SMOTE</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sklearn</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split, GridSearchCV, RandomizedSearchCV, StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, confusion_matrix, recall_score, precision_score, f1_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score, roc_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler, MinMaxScaler, OneHotEncoder, LabelEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> mutual_info_classif</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> ColumnTransformer</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="keyword">from</span> sklearn.utils <span class="keyword">import</span> resample</span><br><span class="line"></span><br><span class="line"><span class="comment"># Models</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression, LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> XGBClassifier</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br></pre></td></tr></table></figure><p>然后我依照老操作进行处理</p><p><img src="/2023/11/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84remake/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20231126222401370.png" alt="image-20231126222401370"></p><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>献给我灵魂的礼赞</title>
      <link href="/2023/11/22/%E7%8C%AE%E7%BB%99%E6%88%91%E7%81%B5%E9%AD%82%E7%9A%84%E7%A4%BC%E8%B5%9E/"/>
      <url>/2023/11/22/%E7%8C%AE%E7%BB%99%E6%88%91%E7%81%B5%E9%AD%82%E7%9A%84%E7%A4%BC%E8%B5%9E/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基本数据结构实现</title>
      <link href="/2023/11/19/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2023/11/19/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>俗话说先进先出，只要一直让最先的出去就行了。就像植物大战僵尸里面豌豆处理僵尸一样，在速度相等的情况总是处理最前面的。按顺序处理。</p><h5 id="关于C语言结构体和指针的补充"><a href="#关于C语言结构体和指针的补充" class="headerlink" title="关于C语言结构体和指针的补充"></a>关于C语言结构体和指针的补充</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">que</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    que* next;</span><br><span class="line">&#125;S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S a1;</span><br><span class="line">    a1.a = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a1.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我对结构体有点忘干净。。。。总是这样也不行，似乎是让变量定义为该对象的指针，然后再调用，通过指针互相指。这是为什么。就不能像简单的类型调用吗。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int s[10001],l[10001],c[10000];</span><br><span class="line"></span><br><span class="line">struct que</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    que* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    que a1;</span><br><span class="line">    a1.a = 1;</span><br><span class="line">    cout&lt;&lt;a1.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作发现，其实是可以的。哦，我弄错了，是因为是typedef的原因，我只知道这是一个变量类型声明，难道他不能像其他结构体变量一样吗。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">que</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    que* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> que AA;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AA a1;</span><br><span class="line">    a1.a = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a1.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从结果上看，它其实就是和其他的结构体一样。</p><p>如果是加上*其实就是定义了一个叫这个名字的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">que</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    que* next;</span><br><span class="line">&#125;b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b a1;</span><br><span class="line">    a1.a = <span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a1.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划之摸鱼传</title>
      <link href="/2023/11/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%91%B8%E9%B1%BC%E4%BC%A0/"/>
      <url>/2023/11/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E6%91%B8%E9%B1%BC%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="g关于动态规划遇到的问题"><a href="#g关于动态规划遇到的问题" class="headerlink" title="g关于动态规划遇到的问题"></a>g关于动态规划遇到的问题</h1><ul><li><p><input disabled type="checkbox"> 用数学描述物体，比如f和h是什么意思?。(h作者没有解释清楚)</p><h3 id="不要读读了两遍以上没有思路的文章-Dilworth定理的介绍"><a href="#不要读读了两遍以上没有思路的文章-Dilworth定理的介绍" class="headerlink" title="不要读读了两遍以上没有思路的文章(Dilworth定理的介绍)"></a>不要读读了两遍以上没有思路的文章(Dilworth定理的介绍)</h3><p>这是一个介绍怎么找最长递减序列</p><p>思路很简单，假设有两个数组一个是你得到的数组<br>$$<br>D<br>$$<br>另一个是你要维护的数组，这个数组表示每一个最长序列的大小<br>$$<br>S<br>$$<br>S一开始是空的。di表示D的第几个数，s.top表示s的顶部元素。对于寻找最长递减序列符合下述规则</p><p>加入第一个元素,i+1</p><p>比较di和S.top的大小，如果di大于si则替换，小于则加入</p><p>这样子最后能把时间复杂度压到nlogn</p><p>今天的摸鱼就到这里</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> -技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的实现喵</title>
      <link href="/2023/11/10/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%96%B5/"/>
      <url>/2023/11/10/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%96%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>问题集</title>
      <link href="/2023/11/01/%E9%97%AE%E9%A2%98%E9%9B%86/"/>
      <url>/2023/11/01/%E9%97%AE%E9%A2%98%E9%9B%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>蜥蜴饲养日记1</title>
      <link href="/2023/10/21/%E8%9C%A5%E8%9C%B4%E9%A5%B2%E5%85%BB%E6%97%A5%E8%AE%B01/"/>
      <url>/2023/10/21/%E8%9C%A5%E8%9C%B4%E9%A5%B2%E5%85%BB%E6%97%A5%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划问题喵</title>
      <link href="/2023/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%96%B5/"/>
      <url>/2023/10/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E5%96%B5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2023/10/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/01/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>不得不品的算法竞赛筑基</title>
      <link href="/2023/09/26/%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%93%81%E7%9A%84%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%AD%91%E5%9F%BA/"/>
      <url>/2023/09/26/%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%93%81%E7%9A%84%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E7%AD%91%E5%9F%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>与连续的爱恨情仇</title>
      <link href="/2023/09/13/%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/"/>
      <url>/2023/09/13/%E4%B8%8E%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87/</url>
      
        <content type="html"><![CDATA[<h3 id="一开始的尝试"><a href="#一开始的尝试" class="headerlink" title="一开始的尝试"></a>一开始的尝试</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>小明这些天一直在思考这样一个奇怪而有趣的问题：</p><p>在 1~ <em>N</em> 的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：</p><p>如果区间 [<em>L</em>,<em>R</em>] 里的所有元素（即此排列的第 <em>L</em>个到第 <em>R</em> 个元素）递增排序后能得到一个长度为 <em>R</em>−<em>L</em>+1 的“连续”数列，则称这个区间连号区间。</p><p>当 <em>N</em> 很小的时候，小明可以很快地算出答案，但是当 <em>N</em> 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。</p><h4 id="一开始的思路"><a href="#一开始的思路" class="headerlink" title="一开始的思路"></a>一开始的思路</h4><p>我想着就是连续排列嘛，那我直接弄出最大最小数，和它的长度不就行了。</p><p>那么要怎么求最大数和最小数呢</p><p>我的思路是在排列的时候偷偷把最大和最小数拿出取去，然后建立以从左到右数列为起点，再建立一个从右到左的循环。然后看每一个第二层循环剔出的数，然后看看符不符合规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> max=<span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> min=<span class="number">99999999</span>;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   <span class="type">int</span> a[n];</span><br><span class="line">   <span class="comment">//有些从一开始</span></span><br><span class="line">   <span class="comment">//只需取最大最小值即可</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(max&lt;=a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min&gt;=a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            min = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="type">int</span> min1 = min;</span><br><span class="line">        <span class="type">int</span> max1 = max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j =n<span class="number">-1</span>;j&gt;=i;j--)</span><br><span class="line">        &#123;   <span class="keyword">if</span>(i==j)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((max1-min1)==(j-i))</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==max1)</span><br><span class="line">            &#123;</span><br><span class="line">                max1--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[j]==min1)</span><br><span class="line">            &#123;</span><br><span class="line">                min1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==max)</span><br><span class="line">            &#123;</span><br><span class="line">                max--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==min)</span><br><span class="line">            &#123;</span><br><span class="line">                min++;</span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样做有两个弊端，就是我是每次都减减，然后我就认为自己能取到最大最小值。这不就是在假设我取的那段线是连续的嘛~，这显然不可能，所以我可以在变小的数等于剔除的那个值+1的时候连减。但这样又会有个问题，假设中间的差值为或者更多会怎么样（这种事情会发生嘛，很显然我们可以举一个例子，23145。)</p><p>这样子，我就要再排序一下，这样子复杂度就来到了n3(我是真的不喜欢复杂度上升)，这个算法和猴子瞎敲有什么区别。</p><p>让我们观察一下前面的数，其实我们可以发现，当要减去最小值的时候，只需减去数组里面的数的数量即可。那我们就叫这个数为惩罚数，只要每一次循环最大最小数没有改变，它就加一</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索性分析（EDA）</title>
      <link href="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/"/>
      <url>/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="探索性分析有什么"><a href="#探索性分析有什么" class="headerlink" title="探索性分析有什么"></a>探索性分析有什么</h2><p>探索性分析分为3类，一种是预处理，一种是数据分布分析（即描述性分析），一种是相关性分析。按照图来分的话是四类，有图单变量，无图单变量，有图多变量，无图多变量</p><h2 id="为什么要探索性分析"><a href="#为什么要探索性分析" class="headerlink" title="为什么要探索性分析"></a>为什么要探索性分析</h2><p>一方面，因为很多检验方法，都是假设物体满足什么分布，一个一个尝试太蠢了。不如先看看。而且探索性分析有一般性步骤（这就跟做某件事的人多了，肯定能提供很多经验。虽然是对是错反而无从考量）</p><h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="关于Numpy"><a href="#关于Numpy" class="headerlink" title="关于Numpy"></a>关于Numpy</h3><h5 id="Numpy的意义"><a href="#Numpy的意义" class="headerlink" title="Numpy的意义"></a>Numpy的意义</h5><p>在我看来,Numpy库就是Pandas库的基础.他的主要优势在于可以实现向量化和广播化。在一般情况下，如果要让其中部分数据全部完成某类运算，要遍历全部元素，而这个要花很多的时间。而Numpy可以很大程度缩减这种时间。之所以这么快，它将相同类型的数据放在一起，来方便它用C和Fortran实现。虽然步骤一样，但Numpy的速度比Python快了近百倍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h5 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Data = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment">#一维数组</span></span><br><span class="line">Data1 =np.array([[<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>],[<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>]])<span class="comment">#二维数组</span></span><br><span class="line"><span class="built_in">print</span>(Data)</span><br><span class="line"><span class="built_in">print</span>(Data1)</span><br><span class="line"><span class="built_in">print</span>(Data.dtype)</span><br></pre></td></tr></table></figure><p>可以看出来，这玩意就是数组，以[]来分隔每一行</p><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240102225728951.png" alt="image-20240102225728951"></p><p>观察其数据类型，我们发现这玩意比python更深。但不用太担心，它们的类型在互相使用时会自动转化</p><h5 id="向量化和广播化"><a href="#向量化和广播化" class="headerlink" title="向量化和广播化"></a>向量化和广播化</h5><p>你可以把向量化和广播化的Numpy特性，理解为水，在加减乘除时，变化会扩散。这是向量化。在与更大的数组计算时，自身的体积也会扩大，虽然是用Nan值填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#向量化过程</span></span><br><span class="line">Data11= Data1+<span class="number">1</span></span><br><span class="line">Data12=Data1*<span class="number">2</span></span><br><span class="line">Data13 =Data1*Data1</span><br><span class="line"><span class="built_in">print</span>(Data1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240102230202069.png" alt="image-20240102230202069"></p><p>可以看出来向量相乘是点乘，如果要进行点积的话方法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = Data1.transpose()</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240102230408093.png" alt="image-20240102230408093"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面是广播化过程</span></span><br><span class="line">B = data+data1</span><br><span class="line"><span class="built_in">print</span>(B)</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20240102230527446.png" alt="image-20240102230527446"></p><p>可以发现一维数据把二维的每一行都加了过去，你可能会好奇二三列相加会怎么样，答案是不行。他只在可能的情况完成广播。</p><h5 id="通用函数"><a href="#通用函数" class="headerlink" title="通用函数"></a>通用函数</h5><p>这里我可能要示范</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T=Data.<span class="built_in">sum</span></span><br><span class="line">T1 = Data.std</span><br><span class="line">T2 = Data.argmin</span><br><span class="line">T3 = Data1.<span class="built_in">sum</span>(axis=<span class="number">1</span>)<span class="comment">#零是按列，1是按行来。</span></span><br><span class="line"><span class="built_in">print</span>(T)</span><br><span class="line"><span class="built_in">print</span>(T1)</span><br><span class="line"><span class="built_in">print</span>(T2)</span><br><span class="line"><span class="built_in">print</span>(T3)</span><br></pre></td></tr></table></figure><h5 id="索引和视图"><a href="#索引和视图" class="headerlink" title="索引和视图"></a>索引和视图</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F = Data[<span class="number">1</span>]</span><br><span class="line">G  =Data1[<span class="number">0</span>,<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(F)</span><br><span class="line"><span class="built_in">print</span>(G)</span><br><span class="line">G[<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(Data1)</span><br></pre></td></tr></table></figure><p>在调用单个点时调用的是标量，而如果是切片调用出来的就是视图，如果改变，原来的值也会改变。</p><h5 id="快速构造函数"><a href="#快速构造函数" class="headerlink" title="快速构造函数"></a>快速构造函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure><h3 id="关于pandas库"><a href="#关于pandas库" class="headerlink" title="关于pandas库"></a>关于pandas库</h3><p>pandas库是一个基于矩阵的自创建的数据结构，至于<em><strong>创建的原因</strong></em></p><h4 id="pandas库的导入"><a href="#pandas库的导入" class="headerlink" title="pandas库的导入"></a>pandas库的导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(A)</span><br><span class="line">A = [[<span class="string">&#x27;Fighter&#x27;</span>,<span class="number">10</span>,<span class="string">&#x27;2022-10-9&#x27;</span>],[<span class="string">&#x27;Magicer&#x27;</span>,<span class="number">7</span>,<span class="string">&#x27;2022-1-9&#x27;</span>]]</span><br><span class="line">N=[<span class="string">&#x27;Type&#x27;</span>,<span class="string">&#x27;LV&#x27;</span>,<span class="string">&#x27;Date&#x27;</span>]</span><br><span class="line">data1= pd.DataFrame(A)</span><br><span class="line"><span class="built_in">print</span>(data1)</span><br><span class="line"><span class="comment">#创建</span></span><br><span class="line">data = pd.DataFrame(data=A,columns=N)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面进行了两次创建操作，一个是直接利用数据进行创建，另一个是基于数据和列名进行创建，如图，效果如下:</p><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20231207173411603.png" alt="image-20231207173411603"></p><p>可以看见，对于上面那个没有列名的，自动给他生成了1,2,3,4…。而左边的是索引，相当于数组中的索引，可以直接标记我们也可以直接定义索引,这个和上面的一样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(data=A,columns=N,index=[<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>需要知道的是，pandas带有一个很基础的功能，可以帮助我们看数据类型，缺失值和数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.info())</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20231207174337976.png" alt="image-20231207174337976"></p><p>需要解释的是显示的是非缺失值的值，可以结合,来看缺失值.当然，如果连计算都懒得计算的话。。。。当然是直接使用计算缺失值的函数拉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这个数据的大小是&quot;</span>,data.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;各个缺失值数量是&quot;</span>,data.isna().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20231207175044979.png" alt="image-20231207175044979"></p><p>很明显，二行三列。但我知道，作为我的读者，肯定不满足与此，这些事不是EXCEL都能搞吗(我要升级m9)</p><p>接下来，我们来了解一些关于索引和列的最基本操作</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>关于给索引的操作有，给索引命名和重建索引，废话不多说，直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.index.rename(<span class="string">&quot;BSZ&quot;</span>))<span class="comment">#给变量命名</span></span><br><span class="line"><span class="built_in">print</span>(data.reset_index())</span><br><span class="line"><span class="built_in">print</span>(data.reset_index().set_index(<span class="string">&quot;LV&quot;</span>))</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20231207180236202.png" alt="image-20231207180236202"></p><p>然后可以用sort_index,sort_value来进行基于它们的排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.sort_index())</span><br><span class="line"><span class="built_in">print</span>(data.sort_value([<span class="string">&quot;LV&quot;</span>]))</span><br></pre></td></tr></table></figure><h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><h5 id="loc和iloc"><a href="#loc和iloc" class="headerlink" title="loc和iloc"></a>loc和iloc</h5><h3 id="关于剔除多余文本"><a href="#关于剔除多余文本" class="headerlink" title="关于剔除多余文本"></a>关于剔除多余文本</h3><h4 id="单一格式"><a href="#单一格式" class="headerlink" title="单一格式"></a>单一格式</h4><p>先讨论最简单的情况，如果你要的东西是某个字符串，然后我们要把它转化为数据（也有可能是编码）</p><h5 id="假设这个文本就是我们要转化的数据"><a href="#假设这个文本就是我们要转化的数据" class="headerlink" title="假设这个文本就是我们要转化的数据"></a>假设这个文本就是我们要转化的数据</h5><p>那么，一般就两种做法进行编码和使用训练好的文本库</p><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h6 id="最常见的编码"><a href="#最常见的编码" class="headerlink" title="最常见的编码"></a>最常见的编码</h6><p>我们可以读入表格，然后利用基本的查找替换功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="不是我们需要的情况"><a href="#不是我们需要的情况" class="headerlink" title="不是我们需要的情况"></a>不是我们需要的情况</h5><p>让我们看一看周围，你要怎么把电脑右下角的时间转化为数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">time_str = <span class="string">&quot;2019/6/11 16:27&quot;</span></span><br><span class="line">datetime_obj = datetime.strptime(time_str, <span class="string">&quot;%Y/%m/%d %H:%M&quot;</span>)</span><br><span class="line"></span><br><span class="line">start_time = datetime(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 设置起始时间为2019年初</span></span><br><span class="line">time_diff = datetime_obj - start_time  <span class="comment"># 计算时间差</span></span><br><span class="line"></span><br><span class="line">minutes = time_diff.total_seconds() // <span class="number">60</span>  <span class="comment"># 转换为分钟数</span></span><br><span class="line"><span class="built_in">print</span>(minutes)</span><br></pre></td></tr></table></figure><p>我们把时间提取成年月日后，再设置了一个起始时间。然后计算时间差之后，再转化为秒数再除以60，就是转化为分钟数<br>同理，下面是转化为小时数，以此类推。从后来学到的知识来看，这里可以记忆为时间步长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(time_diff.total_seconds()//<span class="number">3600</span>)</span><br></pre></td></tr></table></figure><p>当然，对于行读取，可以这么用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="string">&#x27;时间&#x27;</span>] = pd.to_datetime(s[<span class="string">&#x27;时间&#x27;</span>])<span class="comment"># s为dataFrame数据，时间是列名</span></span><br><span class="line">s[<span class="string">&#x27;时间&#x27;</span>]=(s[<span class="string">&#x27;时间&#x27;</span>]-s[<span class="string">&#x27;时间&#x27;</span>][<span class="number">0</span>]).dt.seconds/<span class="number">3600</span></span><br><span class="line"><span class="built_in">print</span>(s.head())</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/blog\myblog\source_posts\探索性分析（DEV）\image-20230819141755613.png" alt="image-20230819141755613"></p><p>得到该结果</p><h1 id="数据分布和相关性分析·"><a href="#数据分布和相关性分析·" class="headerlink" title="数据分布和相关性分析·"></a>数据分布和相关性分析·</h1><h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><p>我们现在有的材料是Kaggle的DEV材料，我的困惑是</p><ul><li><p><input disabled type="checkbox"> ax,和另一个控制基准，</p></li><li><p><input disabled type="checkbox"> 以及它为什么要用循环</p></li><li><p><input disabled type="checkbox"> 如何让这个分布更平衡</p></li></ul><p>ax,subplot是matplot里面的两个属性，一个用来管理单个图片，subplot用来管理图片在多个图片中的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">plot_distribution</span>(<span class="params">data</span>):</span><br><span class="line">    num_cols = <span class="number">4</span></span><br><span class="line">    num_rows = <span class="built_in">len</span>(df_train.columns) // num_cols</span><br><span class="line">    fig, axes = plt.subplots(nrows=num_rows, ncols=num_cols, figsize=(<span class="number">16</span>, <span class="number">4</span>*num_rows))</span><br><span class="line">    sns.<span class="built_in">set</span>(font_scale=<span class="number">1.2</span>, style=<span class="string">&#x27;whitegrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, col_name <span class="keyword">in</span> <span class="built_in">enumerate</span>(df_train.columns):</span><br><span class="line">        <span class="keyword">if</span> col_name != <span class="string">&#x27;Class&#x27;</span>:</span><br><span class="line">            ax = axes[i // num_cols, i % num_cols]</span><br><span class="line">            sns.kdeplot(data=data, x=col_name, hue=target_col, ax=ax, fill=<span class="literal">True</span>, alpha=<span class="number">0.5</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">            <span class="comment"># sns.kdeplot(data=original, x=col_name, hue=target_col, ax=ax, fill=True, alpha=0.5, linewidth=2)</span></span><br><span class="line"></span><br><span class="line">            ax.set_title(<span class="string">f&#x27;<span class="subst">&#123;col_name.title()&#125;</span> Distribution by <span class="subst">&#123;target_col.title()&#125;</span>&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">            ax.set_xlabel(col_name.title(), fontsize=<span class="number">14</span>)</span><br><span class="line">            ax.set_ylabel(target_col.title(), fontsize=<span class="number">14</span>)</span><br><span class="line">            ax.tick_params(axis=<span class="string">&#x27;both&#x27;</span>, which=<span class="string">&#x27;major&#x27;</span>, labelsize=<span class="number">12</span>)</span><br><span class="line">            ax.legend([<span class="number">1</span>, <span class="number">0</span>], title=target_col.title(), fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">plot_distribution(data)</span><br></pre></td></tr></table></figure><p>我们来观察一下这个函数，num_cols是列数。num_rows是行数，他等于数据的列数除以图的每行图片数，即为列数。</p><p>然后下一行，利用plt属性设置了列数和行数，而figsize则安排了图片的高度为16，为每一张图片，安排了四点的宽度空间。<br>sns.set是设置图片属性，font_scale&#x3D;1.2为设置线条长度，style设置风格，风格有</p><ul><li><p>darkgrid</p></li><li><p>whitegrid</p></li><li><p>dark</p></li><li><p>white</p></li><li><p>ticks</p></li></ul><p>我个人喜欢darkgrid。</p><p>然后再往下看，enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。而总所周知,pandas的列名拿出来是列表。</p><p>后面就没什么好解释了。通过除和取余来确认行和列，然后利用ax设置标题，x轴，y轴和刻度尺子，然后设置一下图例</p><h2 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h2><p>绘制折线图有什么用呢，除了能让我们看到数据的相关性以外，还能让我们看到数据的周期性</p><h5 id="一般的折线图绘制"><a href="#一般的折线图绘制" class="headerlink" title="一般的折线图绘制"></a>一般的折线图绘制</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&quot;各元素随时间变化图&quot;</span>)</span><br><span class="line">sns.lineplot(data=s)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/blog\myblog\source_posts\探索性分析（DEV）\image-20230819142906317.png" alt="image-20230819142906317"></p><p>（如果你的中文没显示请加上下面这行代码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]</span><br></pre></td></tr></table></figure><p>我想说，这张图除了PM10在某两个时间很逆天，数据真是乱成一锅粥（笑）。不过我们可以看到大多数数据还是有点周期性的呢，一跳一跳的。而且时间也因为这种关系叠在一起</p><h6 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h6><p>这次我们先试试只画一个来看看，完整代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import pandas as pd</span><br><span class="line">## 导入数据</span><br><span class="line">s = pd.read_csv(&quot;你的文件地址&quot;,encoding=&#x27;gbk&#x27;)#把”你的文件地址”替换成你的文件地址</span><br><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;SimHei&#x27;]  # 设置中文字体为黑体或其他支持中文的字体</span><br><span class="line">## 时间元素替换</span><br><span class="line">s[&#x27;时间&#x27;] = pd.to_datetime(s[&#x27;时间&#x27;])# s为dataFrame数据，时间是列名</span><br><span class="line">s[&#x27;时间&#x27;]=(s[&#x27;时间&#x27;]-s[&#x27;时间&#x27;][0]).dt.seconds/3600</span><br><span class="line">print(s.head())</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(20,10))</span><br><span class="line">plt.title(&quot;PM2.5随时间变化图&quot;)</span><br><span class="line">sns.lineplot(data=s[&#x27;PM2.5&#x27;],label=&quot;PM2.5&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在用过去的小时数时间替代字符串的时间后，我们用label为我们的图命名了</p><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/blog\myblog\source_posts\探索性分析（DEV）\image-20230819145051564.png" alt="image-20230819145051564"></p><p>由于我们以小时为单位计时，我们很自然地联想到一周是168小时，这和pm2.5的变化似乎没有周期性关系。但由图可知，PM2.5是有着周期性的</p><p>让我们看看PM10的表现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">plt.title(<span class="string">&quot;PM2.5随时间变化图&quot;</span>)</span><br><span class="line">sns.lineplot(data = s[<span class="string">&#x27;pm10&#x27;</span>],label = <span class="string">&#x27;pm10&#x27;</span>)</span><br><span class="line">sns.lineplot(data=s[<span class="string">&#x27;PM2.5&#x27;</span>],label=<span class="string">&quot;PM2.5&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/blog\myblog\source_posts\探索性分析（DEV）\image-20230819145815799.png" alt="image-20230819145815799"></p><p>可以看到PM10和PM2.5叠在一起，似乎有着很强的相关性（画个热力图看看吧），而之前凸出的几个点还是PM10(跟异常值一样)不过。其实，不把data数据不按起始时间算更方便一点呢</p><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20230819150906229.png" alt="image-20230819150906229"></p><h2 id="bar-AND-HEAT"><a href="#bar-AND-HEAT" class="headerlink" title="bar AND HEAT"></a>bar AND HEAT</h2><h3 id="bar-柱状图"><a href="#bar-柱状图" class="headerlink" title="bar(柱状图)"></a>bar(柱状图)</h3><p>柱状图其实不少见了，用来统计大小和多少什么的。有什么意义呢，可以看看平均值，最高值什么的，会有好一点的感觉</p><p>让我们猜测一下，柱状图的代码是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20230819152946502.png" alt="image-20230819152946502">事实也是如此，让我们过了吧（笑).可以看到PM2.5的污染治理在蒸蒸日上嘛</p><h3 id="heatmap"><a href="#heatmap" class="headerlink" title="heatmap"></a>heatmap</h3><p>热力图的原理就不多做介绍，就是协方差。上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.rcParams[&#x27;font.sans-serif&#x27;] = [&#x27;Arial Unicode MS&#x27;]</span><br><span class="line">p = s.corr()</span><br><span class="line">plt.figure(figsize=(20,10))</span><br><span class="line">sns.heatmap(data=p,annot=True,square=True,cmap=&#x27;coolwarm&#x27;)</span><br><span class="line">plt.title(&quot;热力图&quot;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20230819155237890.png" alt="image-20230819155237890"></p><p>和我猜测的一样，PM2.5和PM10相关性很高，O3几乎和谁都不兼容。</p><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20230819162537369.png" alt="image-20230819162537369"></p><p>还是老样子，具有很强的周期性的样子啊</p><p>让我们对他拟合一下</p><p><img src="/2023/08/18/%E6%8E%A2%E7%B4%A2%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%88DEV%EF%BC%89/Users\月神客\AppData\Roaming\Typora\typora-user-images\image-20230819163900297.png" alt="image-20230819163900297"></p><p>总体呈现下降趋势</p><h1 id="泰坦尼克-死亡乐透"><a href="#泰坦尼克-死亡乐透" class="headerlink" title="泰坦尼克-死亡乐透"></a>泰坦尼克-死亡乐透</h1><p>为什么要采用重采样技术</p><p>它是什么，好在我不用</p><p>有什么数据处理我在学习中的</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>不用多解释，这是惯例了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data analysis and wrangling</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random <span class="keyword">as</span> rnd</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;darkgrid&#x27;</span>, font_scale=<span class="number">1.4</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># machine learning</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC, LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Perceptron</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> lightgbm <span class="keyword">import</span> LGBMClassifier</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="DEV"><a href="#DEV" class="headerlink" title="DEV"></a>DEV</h2><p>很好，让我们来探索一下那些老到掉牙的数据</p><p>首先让我们看一看</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>按照不存在的惯例，我们来看看数据的构成类型，一般来说数据分为四类，定量，定序，定比，和定量变量，这里我们先用定类统称前面两种。</p><p>这很容易解释欠采样或者过采用，欠采样是数据太少导致的过拟合。而过采样则是由于某类数据过多而导致的。</p><h3 id="定类变量："><a href="#定类变量：" class="headerlink" title="定类变量："></a>定类变量：</h3><p>按我的记忆这里有，编号，名字，票的等级，父母，兄弟姐妹，登船口，和所处船舱的位置(Cabin)<br>我所依照的教程没有对Cabin进行任何开发，但你知道，这不公平。这就跟你地震来了，在不在厕所里面一样。换个类似的说法，你在不在一楼。你知道，一楼可以随时跳窗逃生。</p><p>根据肉眼法我发现里面有个G&#x2F;S&#x2F;C的东西，我有没有什么好办法把它分开来呢，还有编号，我想知道这玩意是不是和宇宙泰坦尼克一样，从小到达往前排，最前面的人可以第一时间和冰山美人零距离接触。</p><p>这很有趣，我也想把这玩意分开来，从而加深的我的理解深度，更何况，我想做一个更好的模型<br>但结果这是太糟了，在Cabin里面有大量的缺失值，如果我想进一步探索就得解读那里面的关系。我已经发现同一字母开头的，Cabin差即为编号位。但我不了解Cabin为什么有那种Bxxx Bxxx Bxxx这种座位的，可以理解为家人票吗。</p><p>看样子并不是，有可能只是单纯一个人占有很多位置而已。从座位编号中我还能挖掘出什么吗。不行吗，似乎是这样，我没办法挖掘，因为我认为里面有太多缺失值。</p><p>要是缺失值没那么多就好了，有没有一个办法，去观察现有的值和所处位置的关系，也就是说，在只考虑前面的情况下，思考S和C的关系。但这得有一个前提，我能有办法去知道作为的上下文。很可惜，失败的尝试。接下来我只能暂时去模仿那些厉害的家伙的行为了，他们居然靠着模型袋装把正确率提高到一。</p><p>数据处理</p>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于微分方程，爬虫，决策的综合练习</title>
      <link href="/2023/08/07/%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
      <url>/2023/08/07/%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="关于实践"><a href="#关于实践" class="headerlink" title="关于实践"></a>关于实践</h2><p>我想试着用新学到的模型来分析股票涨落，首先，拟合要被率先排除，因为拟合从长远看一定是趋于无限大或者无限小的，这对于股票来说不科学（但也可以尝试短期）。然后，我要爬取股票的相关信息。我能不能爬取新闻中的有用情报呢。这需要文本分析，然后我就只有决策树，微分模型两种拟合方式，应该稍微试一试</p><h3 id="数据的爬取"><a href="#数据的爬取" class="headerlink" title="数据的爬取"></a>数据的爬取</h3><p>原本一看，傻眼了。怎么这么多呢，然后再细细翻来，发现其实在一个xgr的his开头的请求中，到时候只要把标号弄好就行了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杂记</title>
      <link href="/2023/08/03/%E6%9D%82%E8%AE%B0/"/>
      <url>/2023/08/03/%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>##做题系列<br>做一道题，给出坐标，让我求三角形边长。如果是正常就再简单不过了。但在电脑上，我就会担心精度的问题。在那么大尺度相乘下，会不会出现在末端有个微点进了一位，后面又刚好是0.99999这样子。但是考虑结果的保留两位，影响比较大的是第三位是4的情况</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习入门</title>
      <link href="/2023/07/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"/>
      <url>/2023/07/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="基本参数与概念"><a href="#基本参数与概念" class="headerlink" title="基本参数与概念"></a>基本参数与概念</h2><h3 id="误差函数"><a href="#误差函数" class="headerlink" title="误差函数"></a>误差函数</h3><p>这应该表明自己对样本数据集的差。根据我们需要的效果，我们会用不同的函数来表达这个程度。计算公式为样本预测量减去实际值。然后我们会用一个预测函数来放大这值。有以下几类状态</p><h4 id="0-1"><a href="#0-1" class="headerlink" title="0-1"></a>0-1</h4><p>就是只记住符合还是不符合的，了解一点类与量的关系的，都能理解：这是很适合非定量数据的一种计量方法</p><h4 id="绝对值和平方"><a href="#绝对值和平方" class="headerlink" title="绝对值和平方"></a>绝对值和平方</h4><p>得值为差的平方，或者绝对值。没什么好说的</p><h4 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h4><p>没什么好说的，之后都没用到；本质上还是单调函数</p><h3 id="经验误差"><a href="#经验误差" class="headerlink" title="经验误差"></a>经验误差</h3><p>经验函数的本质就是误差的相加。把各个点的误差相加，然后除以样本总数；就跟游戏里面的综合战败点一样吧。当样本的量接近于无穷的时候，经验误差会接近于理想误差。但是，再样本误差很小的情况，当模型复杂度增加，会出现经验误差减小。当复杂度到达一定临界值，测试误差会上升，出现过拟合现象。为了应对这种情况，我们在，经验误差中加入了L函数。</p><h4 id="L"><a href="#L" class="headerlink" title="L"></a>L</h4><p>由于模型的复杂度上升，很容易出现过拟合的情况。L函数是一种描述模型复杂度的函数，它有三种类型，点，正方体，圆</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><p>这里推荐五折验证，就是把数据随机分成五份，留下了一份用来验证，剩下的用来验证</p><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>决策树是一种可以用来回归和分类的方法，它是根据贪心算法进行的，根据信息熵用模型计算后求最小值的一种算法。它会根据贪心算法，一步一步给每一个树叶分类，直到不能再小为止</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><h4 id="什么是信息熵"><a href="#什么是信息熵" class="headerlink" title="什么是信息熵"></a>什么是信息熵</h4><p>这就是描述一个混乱程度的指标。什么是混乱程度，你可以去联想一下你的房间，在整洁的状态下，东西很好找，混乱则相反。<br>可是，数据集没有空间位置之分啊。我们可以在联想房间，你的东西种类越多，就越难找。再比如说，当大物件比较多的时候，虽然小东西难找，但大物件很方便。</p><h4 id="信息熵的程度描述"><a href="#信息熵的程度描述" class="headerlink" title="信息熵的程度描述"></a>信息熵的程度描述</h4><p>H（x） &#x3D; Elog2（p（i））*-p（i），其中H表示信息熵，p（i）表示某件事发生的概率</p><h3 id="经典模型"><a href="#经典模型" class="headerlink" title="经典模型"></a>经典模型</h3><h4 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h4><p>ID3的特点就是根据信息增益的最大来取根节点。什么是信息增益，就是原本的信息熵减去（分类后所有类型的信息熵之和）的值。很容易看出来，这样子如果我们按照那些独特性很强的变量，比如名字，编号，一下子信息熵就归零了。但是这样分了又等于没有分</p><h4 id="ID4-5"><a href="#ID4-5" class="headerlink" title="ID4.5"></a>ID4.5</h4><p>为了应对上面那种情况，加入了信息增益率</p><h2 id="练习v关于2022年C题"><a href="#练习v关于2022年C题" class="headerlink" title="练习v关于2022年C题"></a>练习v关于2022年C题</h2><h4 id="原题目"><a href="#原题目" class="headerlink" title="原题目"></a>原题目</h4><p>丝绸之路是古代中西方文化交流的通道，其中玻璃是早期贸易往来的宝贵物证。早期的玻<br>璃在西亚和埃及地区常被制作成珠形饰品传入我国，我国古代玻璃吸收其技术后在本土就地取<br>材制作，因此与外来的玻璃制品外观相似，但化学成分却不相同。<br>玻璃的主要原料是石英砂，主要化学成分是二氧化硅（SiO2）。由于纯石英砂的熔点较高，<br>为了降低熔化温度，在炼制时需要添加助熔剂。古代常用的助熔剂有草木灰、天然泡碱、硝石<br>和铅矿石等，并添加石灰石作为稳定剂，石灰石煅烧以后转化为氧化钙（CaO）。添加的助熔<br>剂不同，其主要化学成分也不同。例如，铅钡玻璃在烧制过程中加入铅矿石作为助熔剂，其氧<br>化铅（PbO）、氧化钡（BaO）的含量较高，通常被认为是我国自己发明的玻璃品种，楚文化<br>的玻璃就是以铅钡玻璃为主。钾玻璃是以含钾量高的物质如草木灰作为助熔剂烧制而成的，主<br>要流行于我国岭南以及东南亚和印度等区域。<br>古代玻璃极易受埋藏环境的影响而风化。在风化过程中，内部元素与环境元素进行大量交<br>换，导致其成分比例发生变化，从而影响对其类别的正确判断。</p><p>现有一批我国古代玻璃制品的相关数据，考古工作者依据这些文物样品的化学成分和其他<br>检测手段已将其分为高钾玻璃和铅钡玻璃两种类型。附件表单 1 给出了这些文物的分类信息，<br>附件表单 2 给出了相应的主要成分所占比例（空白处表示未检测到该成分）。这些数据的特点<br>是成分性，即各成分比例的累加和应为 100%，但因检测手段等原因可能导致其成分比例的累<br>加和非 100%的情况。本题中将成分比例累加和介于 85%~105%之间的数据视为有效数据。<br>请你们团队依据附件中的相关数据进行分析建模，解决以下问题：<br>问题 1 对这些玻璃文物的表面风化与其玻璃类型、纹饰和颜色的关系进行分析；结合玻<br>璃的类型，分析文物样品表面有无风化化学成分含量的统计规律，并根据风化点检测数据，预<br>测其风化前的化学成分含量。<br>问题 2 依据附件数据分析高钾玻璃、铅钡玻璃的分类规律；对于每个类别选择合适的化<br>学成分对其进行亚类划分，给出具体的划分方法及划分结果，并对分类结果的合理性和敏感性<br>进行分析。<br>问题 3 对附件表单 3 中未知类别玻璃文物的化学成分进行分析，鉴别其所属类型，并对<br>分类结果的敏感性进行分析。<br>问题 4 针对不同类别的玻璃文物样品，分析其化学成分之间的关联关系，并比较不同类<br>别之间的化学成分关联关系的差异性。</p><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><p>观察所给材料，由于成分少，样本数据缺失，因此不需要使用降维处理。按照将分类数据转化为定量数据或者编码后，即可进行操作。（虽然之前弄过好多次，可是对元胞数组，表之类的还是有点糊</p><h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>处理相关性，已知的相关性模型有卡方，多元，皮尔斯系数。。。。。我记得也有用多元来搞定类回归的。。。。还有一个是根据最大数似然；这些东西我最熟的就只有皮尔斯了。但这道题明显是一个定类数据的问题-》可能的点，方差估计<br>遇到的问题，知网找不到论文。。。</p><h4 id="概率模型的练习"><a href="#概率模型的练习" class="headerlink" title="概率模型的练习"></a>概率模型的练习</h4><p>尝试使用regress模型，成功，发现系数，系数信度，残差，和残差信度还有综合统计值（r，F值来表示拟合优度的）</p><h4 id="关于实践"><a href="#关于实践" class="headerlink" title="关于实践"></a>关于实践</h4><p>我想试着用新学到的模型来分析股票涨落，首先，拟合要被率先排除，因为拟合从长远看一定是趋于无限大或者无限小的，这对于股票来说不科学。然后，我要爬取股票的相关信息。我能不能爬取新闻中的有用情报呢。这需要文本分析，然</p><img src="/2023/07/31/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/A.png" class title="我的图片">]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于机器学习的文本处理</title>
      <link href="/2023/07/29/%E5%85%B3%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
      <url>/2023/07/29/%E5%85%B3%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="机器学习的文本处理"><a href="#机器学习的文本处理" class="headerlink" title="机器学习的文本处理"></a>机器学习的文本处理</h3><p>在机器学习中，由于[人类的多样性]，从网上搜素的文本库充满了错别字，近义词，以及一些奇奇怪怪的表情符号和无意义词汇。另一方面，如果不把文本分解成数值特征，是无法用来机器学习的</p><h4 id="词袋法"><a href="#词袋法" class="headerlink" title="词袋法"></a>词袋法</h4><p>这是一种很常见的技术，在python中可以通过scikit-learn有一个feature_extraction模块可以帮助我来实现它。其基本思想是，根本不管一句话里面的语法，只计量里面出现的词汇，和计量数。而储存文本的东西叫做袋子，只计量词汇的数量。就好像一个商店，只显示你有的物体量</p><p>这个办法有三步：分词，计数 归一化</p><p>分词：将单词从空格和逗号中分出（这个自己也可以实现）</p><p>计数：计算文档次数的出现次数</p><p>归一化：将文档按重要性排序</p><p>CountVec</p><h4 id="Tf-IDF向量化器"><a href="#Tf-IDF向量化器" class="headerlink" title="Tf-IDF向量化器"></a>Tf-IDF向量化器</h4>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于微分方程</title>
      <link href="/2023/07/28/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
      <url>/2023/07/28/%E5%85%B3%E4%BA%8E%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么发现事物的关系"><a href="#怎么发现事物的关系" class="headerlink" title="怎么发现事物的关系"></a>怎么发现事物的关系</h2><h3 id="一些考虑"><a href="#一些考虑" class="headerlink" title="一些考虑"></a>一些考虑</h3><p>如果要建立速度与位移变化趋势，我会进行受力分析，说白了。我会考虑已知量和未知量的联系。。。</p><h4 id="大概的来源"><a href="#大概的来源" class="headerlink" title="大概的来源"></a>大概的来源</h4><p>与建立微分方程相关的方法论，《数学模型》,一些经验贴，</p><h4 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h4><p>估计会发现多种理论，以数学模型书中方案为准。我会发现有些东西有用，而有些没有软用。总之，我会更了解这个</p><h3 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h3><h4 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h4><p>没找到查找相关的方法论。与之相关的内容是相关的题型。和我总结的差不多，包括机理分析类，即我说的微分方程类。根据查阅的资料，知识经验来给出明确的关系式。数据分析类，根据拟合数据的输入输出，利用统计学知识，来寻找变量的关系。最典型的是回归性分析，机器学习，卡方那一类；以及类比仿真，这一类我有见过，当时只道平常。但怎么做我不清楚，他是用什么来表示相关变量的关系的。似乎是假设某些东西的关系，像印象中的模型来行动。</p><h4 id="经验帖的概况"><a href="#经验帖的概况" class="headerlink" title="经验帖的概况"></a>经验帖的概况</h4><h5 id="关键词-数学建模搜索"><a href="#关键词-数学建模搜索" class="headerlink" title="关键词 数学建模搜索"></a>关键词 数学建模搜索</h5><h6 id="1"><a href="#1" class="headerlink" title="1"></a>1</h6><p>方法（模型）：中国知网或者维普，万方，GOOGLE学术等，首先要就建模题目查找相关文献，了解专业背景；数学中国，上边可以找到很多有用的资料，可以自己整理成资料库；<br>数据：数据堂，国家或者城市的统计局网站，年鉴等等，搜索需要的数据；<br>程序：pudn，csdn，GOOGLE code等，就将要使用的方法搜索相关代码；<br>写作：最关键的是你得能把要表达的内容，清晰流畅地写在论文里，这就需要学好word排版或Tex排版，并且经常阅读文献才能培养出来。这方面资源自行搜索。</p><h6 id="2"><a href="#2" class="headerlink" title="2"></a>2</h6><p>主张在查阅相关资料时查找图书，来获得深入浅出的认识，也提到了类比。我想起来美赛时用卡车关系来联想帆船的朋友。大家都是固体液体气体，是可以碰到的，受重力作用</p><h6 id="3"><a href="#3" class="headerlink" title="3"></a>3</h6><h2 id="关于类比仿真"><a href="#关于类比仿真" class="headerlink" title="关于类比仿真"></a>关于类比仿真</h2><h3 id="猜测"><a href="#猜测" class="headerlink" title="猜测"></a>猜测</h3><p>听名字和我认识的，以海浪来比喻进军还挺相似的。我会用波利亚的解决问题步骤来理解数学建模的步骤，然后发现他们的不同。但关于这个，是基于对事物有熟悉的结构吗。</p><h3 id="仿真模型"><a href="#仿真模型" class="headerlink" title="仿真模型"></a>仿真模型</h3><p>初略查阅了一下，文献。仿真其实就是用程序来模拟过程的函数。我可以得到中间任何一部的结果，像是抛出一百枚硬币，我可以用随机数仿真。像是遗传算法，其实也是仿真。模拟寻找最优解过程；好像和我学的算法不冲突欸。</p><h3 id="怎么利用仿真模型"><a href="#怎么利用仿真模型" class="headerlink" title="怎么利用仿真模型"></a>怎么利用仿真模型</h3><p>其实我也是糊涂，怎么没想到用这个来解决问题。那还有什么能解决问题，假说检验法？投标问路，条件弱化的探索法，或者单纯的为什么。挺有意思的</p>]]></content>
      
      
      <categories>
          
          <category> -问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间序列/力学/遗传算法</title>
      <link href="/2023/07/24/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97-%E5%8A%9B%E5%AD%A6-%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/24/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97-%E5%8A%9B%E5%AD%A6-%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="探索的意义"><a href="#探索的意义" class="headerlink" title="探索的意义"></a>探索的意义</h2><p>遗传算法有助于寻找最优解（这种迭代算法可以找到更好的，而且具有扩散的能力</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>图论相关</title>
      <link href="/2023/07/22/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/07/22/%E5%9B%BE%E8%AE%BA%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么要求解利用图论"><a href="#为什么要求解利用图论" class="headerlink" title="为什么要求解利用图论"></a>为什么要求解利用图论</h4><h4 id="概念以及各个性质的现实意义"><a href="#概念以及各个性质的现实意义" class="headerlink" title="概念以及各个性质的现实意义"></a>概念以及各个性质的现实意义</h4><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><h5 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h5><p>这是一个处理两点之间最短路的算法，其中心思想是，从起点开始，每次选择距离起点最近的未访问过的顶点，然后更新其他顶点到起点的距离，直到所有顶点都被访问过或者到达终点。如果在一条最短路径中，任意两点的路径也应该是最小值。这很好理解，因为如果不是最小值，那就很容易被代替掉了</p><p>算法实现</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%在matlab中，就一个.G表示你构造的图，1是起始点位置，11则为目标</span></span><br><span class="line">[p,d]=shortestpath(G,<span class="number">1</span>,<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>那么，这个算法是怎么实现的</p><p>根据其核心思想，我们可以想象三个袋子，一个装着已经探索过的点及其距离，而另一个则为没探索完的点及其距离。从A开始肯定有最短路径，因为如果选择其他路，单是另一条路就比最小途径大。不符合题意。其他的也依此类推，从A到B最短，从B到C最短。从而找到最小路。问题的关键是，你已经遍历了所有可能的状态</p><h5 id="全部"><a href="#全部" class="headerlink" title="全部"></a>全部</h5><h4 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h4><h5 id="关于连通图"><a href="#关于连通图" class="headerlink" title="关于连通图"></a>关于连通图</h5><h5 id="设计算法"><a href="#设计算法" class="headerlink" title="设计算法"></a>设计算法</h5><h5 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h5><h5 id="Ktuskal算法"><a href="#Ktuskal算法" class="headerlink" title="Ktuskal算法"></a>Ktuskal算法</h5><h4 id="最大最小流"><a href="#最大最小流" class="headerlink" title="最大最小流"></a>最大最小流</h4><h4 id="着色问题"><a href="#着色问题" class="headerlink" title="着色问题"></a>着色问题</h4><h5 id="关于异色的描述"><a href="#关于异色的描述" class="headerlink" title="关于异色的描述"></a>关于异色的描述</h5><h4 id="计划路线"><a href="#计划路线" class="headerlink" title="计划路线"></a>计划路线</h4><h5 id="什么样的是事件网络"><a href="#什么样的是事件网络" class="headerlink" title="什么样的是事件网络"></a>什么样的是事件网络</h5><h5 id="时间参数问题"><a href="#时间参数问题" class="headerlink" title="时间参数问题"></a>时间参数问题</h5><h5 id><a href="#" class="headerlink" title></a></h5><h4 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h4><h5 id="为什么要修改圈近似"><a href="#为什么要修改圈近似" class="headerlink" title="为什么要修改圈近似"></a>为什么要修改圈近似</h5>]]></content>
      
      
      
        <tags>
            
            <tag> question </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划基于matlab的求解</title>
      <link href="/2023/07/21/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%9F%BA%E4%BA%8Ematlab%E7%9A%84%E6%B1%82%E8%A7%A3/"/>
      <url>/2023/07/21/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%9F%BA%E4%BA%8Ematlab%E7%9A%84%E6%B1%82%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p> 涉及内容：线性规划方程组的解释，matlab求解方法，在绝对值情况的转化，怎么进行灵敏度分析</p><h3 id="线性规划方程"><a href="#线性规划方程" class="headerlink" title="线性规划方程"></a>线性规划方程</h3><h4 id="规划方程组的概念"><a href="#规划方程组的概念" class="headerlink" title="规划方程组的概念"></a>规划方程组的概念</h4><p>包括目标函数和限制条件，目标函数就是用来表示各个变量造成一个结果的函数，限制条件是表示变量的关系式，比如某几个变量加权后相加大于某个值，某些变量加权后等于某个值。它就像旅行选择路径，你的快乐程度与你路途的风景（X2），路上的时间（X3），吃的东西(X4)，体验到的文化(X5)相关。假设他们是最简单的线性关系，那么就是快乐程度 &#x3D; X2+X3+X4+X5.而上列事物又受到你的体力，金钱，假期时间所限制。比如：快乐程度不可能超过人类能体验的上限。吃的东西，路费+体验文化不能超过你给自己的经费。</p><h4 id="怎么建立线性规划方程"><a href="#怎么建立线性规划方程" class="headerlink" title="怎么建立线性规划方程"></a>怎么建立线性规划方程</h4><p>当前笔者的做法是，寻找已知的所有关系，找出能符合条件所有关系式，然后来寻找变量</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>市场上有 n 种资产（如股票、债券、…）Si ( i&#x3D;1,…n) 供投资者选择，某公司有数额为 M 的<br>一笔相当大的资金可用作一个时期的投资。公司财务分析人员对这 n 种资产进行了评估，估算出<br>在这一时期内购买 Si 的平均收益率为 ir ，并预测出购买 Si 的风险损失率为 qi 。考虑到投资越分<br>散，总的风险越小，公司确定，当用这笔资金购买若干种资产时，总体风险可用所投资的 Si 中<br>最大的一个风险来度量。<br>购买 Si 要付交易费，费率为 pi ，并且当购买额不超过给定值ui 时，交易费按购买ui 计算（不<br>买当然无须付费）。另外，假定同期银行存款利率是 0r , 且既无交易费又无风险。（ 0r &#x3D;5%）</p><p>试给该公司设计一种投资组合方案，即用给定的资金 M ，有选择地购买若干种资产或存银行生<br>息，使净收益尽可能大，而总体风险尽可能小</p><h4 id="线性规划函数的求解程序"><a href="#线性规划函数的求解程序" class="headerlink" title="线性规划函数的求解程序"></a>线性规划函数的求解程序</h4><h4 id="如何转化绝对值问题"><a href="#如何转化绝对值问题" class="headerlink" title="如何转化绝对值问题"></a>如何转化绝对值问题</h4><h3 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h3><h4 id="整数规划的定义"><a href="#整数规划的定义" class="headerlink" title="整数规划的定义"></a>整数规划的定义</h4><p>当一个或者多个个变量只能取整数时，这个问题被称为整数规划。所以它有一下几种类型，部分变量取整数，混合整数规划；全部变量为整数，纯整数规划；全部只能取零一的情况，0-1整数规划</p><h4 id="整数规划的常见类型"><a href="#整数规划的常见类型" class="headerlink" title="整数规划的常见类型"></a>整数规划的常见类型</h4><h5 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h5><p>有n个不停物体供你选择，你的背包容量为nkg，每件物体的价格各异。让你在同等条件下，带最值钱的物体<br>这是一套很经典的0-1规划问题，在携带条件中，取某件物体只能取零件或者一件</p><h5 id="怎么进行编程表示"><a href="#怎么进行编程表示" class="headerlink" title="怎么进行编程表示"></a>怎么进行编程表示</h5><h6 id="笔者的思路"><a href="#笔者的思路" class="headerlink" title="笔者的思路"></a>笔者的思路</h6><p>既然是0-1的整数，使用int类型（应该有类型判断函数，然后不符合求剔除。）</p><h6 id="代码实现尝试"><a href="#代码实现尝试" class="headerlink" title="代码实现尝试"></a>代码实现尝试</h6><h5 id="什么叫派遣问题"><a href="#什么叫派遣问题" class="headerlink" title="什么叫派遣问题"></a>什么叫派遣问题</h5><p>这个问题的特点在于有x个人，有n件事情要干，每个人干某件事情带来的价值不一样。</p><h6 id="笔者的思路-1"><a href="#笔者的思路-1" class="headerlink" title="笔者的思路"></a>笔者的思路</h6><p>可以把某人干某件事单独用一个变量表示出来，如果有a个人，b件事情，那就有a*b个变量，每个变量就乘以A人干B事的价值，再相加</p><h6 id="书上的思路"><a href="#书上的思路" class="headerlink" title="书上的思路"></a>书上的思路</h6><p>和笔者一样。要补充说明的是这个问题与背包客问题最大的区别就是，有两个条件需要满足，即每件事只能让一个人来干，一个人只能干一件事。那么则有，关于第A事的变量和为1，关于第B事的变量和为1，</p><h5 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h5><p>一共有n个城市，每个城市之间都有路。旅行商要历经所有城市，不能重复，然后要返回最初的城市。每个城市的价值不同</p><h6 id="笔者的思路-2"><a href="#笔者的思路-2" class="headerlink" title="笔者的思路"></a>笔者的思路</h6><p>和派遣问题类似，派遣问题有2种项目用于选择，这个问题也有2种。一个是进入其他城市，另一个变量是被其他城市进入。很容易想到要建立n的平方个变量。并且有每个城市进入别的城市的次数的和离开别的城市的次数的和都为一。问题在于怎么表示首尾相连，我觉得只要让A城市进入了B城市和B城市被A进入一致就行了。这样它就一定不会断开。这样的话，如果它在A以外的地方形成闭环。如果是形成有自由点，那肯定不符合进入和离开都为1的情况。如果没有自由点，那得有一点进入的点为2.那肯定不成立。</p><h6 id="关于怎么保证返回出发城市"><a href="#关于怎么保证返回出发城市" class="headerlink" title="关于怎么保证返回出发城市"></a>关于怎么保证返回出发城市</h6><p>书上独立再设定了一个变量u，让出发城市为0，其他城市从取2到n-1的任意值；然后定义了一个关系式，ui - uj+n*xij《&#x3D;n-1，其中，ui的取值为0到你<br>，uj的取值为2到n-1.笔者的思路的最大问题就是，进入和离开的一致不代表只有一条线。可能会出现某些城市首尾自己连成环的情况。而这个关系式，如果出现了这种情况，就有不同关系式的ui，uj全部消掉，n左右消掉，变成0《&#x3D;-n，这显然不成立。但对于初始城市，因为uj取不到它，就不会出现消掉的情况。</p><h4 id="整数规划的求解程序"><a href="#整数规划的求解程序" class="headerlink" title="整数规划的求解程序"></a>整数规划的求解程序</h4><p>这是上面出现的optimvar模型</p><h4 id="非线性条件的线性化"><a href="#非线性条件的线性化" class="headerlink" title="非线性条件的线性化"></a>非线性条件的线性化</h4><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h3 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h3><h4 id="关于非线性规划"><a href="#关于非线性规划" class="headerlink" title="关于非线性规划"></a>关于非线性规划</h4><h5 id="什么是非线性规划"><a href="#什么是非线性规划" class="headerlink" title="什么是非线性规划"></a>什么是非线性规划</h5><h5 id="什么是凸规划"><a href="#什么是凸规划" class="headerlink" title="什么是凸规划"></a>什么是凸规划</h5><h5 id="凸规划应该符合什么性质"><a href="#凸规划应该符合什么性质" class="headerlink" title="凸规划应该符合什么性质"></a>凸规划应该符合什么性质</h5><h5 id="为什么凸规划局部最优解就是全局最优解"><a href="#为什么凸规划局部最优解就是全局最优解" class="headerlink" title="为什么凸规划局部最优解就是全局最优解"></a>为什么凸规划局部最优解就是全局最优解</h5><h4 id="飞行问题的例子"><a href="#飞行问题的例子" class="headerlink" title="飞行问题的例子"></a>飞行问题的例子</h4><h4 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h4>]]></content>
      
      
      <categories>
          
          <category> 技术笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥（关于时间问题）</title>
      <link href="/2023/07/20/%E8%93%9D%E6%A1%A5%EF%BC%88%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2023/07/20/%E8%93%9D%E6%A1%A5%EF%BC%88%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客的创建（二）：对网页进行编辑与写作</title>
      <link href="/2023/07/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AF%B9%E7%BD%91%E9%A1%B5%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%BE%91/"/>
      <url>/2023/07/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AF%B9%E7%BD%91%E9%A1%B5%E8%BF%9B%E8%A1%8C%E7%BC%96%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="怎么创建tag"><a href="#怎么创建tag" class="headerlink" title="怎么创建tag"></a>怎么创建tag</h3><p>tag应该属于主题或者Hexo自带的_config.yml文档中的东西。之前阅读过Butterfly的readme，里面不包括此类内容。所以我可以在yml文档中找到。在花30秒左右后扫一眼，发现了# Category &amp; Tag的存在。</p><h4 id="尝试："><a href="#尝试：" class="headerlink" title="尝试："></a>尝试：</h4><p>创建在Tag中添加需要的字符，如果不行就删除掉。如果结果正确，在我的网站里，标签会新加一个。</p><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p>我生成了一下看看，结果是报错了。然后我百度了一下，可以直接依靠命令生成。我没有仔细读，因为我觉得和我想要的内容无关。我直接尝试添加在头文件的tag里.</p><h4 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h4><p>我阅读了那篇文章。它描述了如何创建一个标签和分类页。后期有在文章中添加标签的示范。它没有明确表明创建了一个标签。但联系前面没有任何创建标签的内容，很有可能这是答案。依葫芦画瓢，成功了。<br>那时我想着怎么去创建标签，直接添加标签的事情我也做过（我的指令不对，但没有报错）。所以事实上我没有获得这篇文章的信息，而是跳来跳去让自己的短时记忆崩溃。所以我是在拼命地寻找一个可以帮助自己的教程</p><h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>我常常为了解决问题做这样的事情：打开自己熟悉的搜索引擎和平台搜索自己的问题，东看一些，西看一点，然后让满屏都是自己的网页。那时我想着怎么去创建标签，直接在文章头·添加标签的事情我也做过（我的指令不对，但没有报错）。我是在另<br>一篇教程中无果才进行尝试的。事实上在那之前，我没有获得这篇文章的信息，而是跳来跳去让自己的短时记忆崩溃。我是在拼命地寻找一个可以帮助自己的教程。<br>如果没有这类教程，一到两个月内我都无法创建一个博客。那么我的思路可以从以下两点入手，提高尝试效率，加快查找效率</p><h3 id="怎么更改主页图片和用户名"><a href="#怎么更改主页图片和用户名" class="headerlink" title="怎么更改主页图片和用户名"></a>怎么更改主页图片和用户名</h3><p>hexo,或者主题肯定有自己配置的工具</p><h4 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h4><p>直接搜索“hexo””yonghuming”关键词。发现相关教程提供佐证，开始尝试。可以直接修改主题配置文件。在主题配置文件加入照片。</p><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><p>显而易见，我成功了。但事实上并不顺利。我试着按要求的改变yml文件，但头像，和其他标签页也不显示。我甚至一怒之下直接把预设文章删除了，结果也是没有任何影响。我的网站仍然可以运行，从那时我就在想，这是什么鬼。然后我开始回忆起来，我的主题用的不是从官网下载的，而是用cmd下载的。我的预设文件在node_modules那一行里。按照教程我很快就成功配置了主页图，头像以及菜单</p><h4 id="方案：-1"><a href="#方案：-1" class="headerlink" title="方案："></a>方案：</h4><p>打开你_config.yml或者主题其它以这个结尾的文件，找到avatar，把地址换成放入主题img的图片地址就行了。</p><h3 id="文章相关"><a href="#文章相关" class="headerlink" title="文章相关"></a>文章相关</h3><h4 id="怎么插入图片"><a href="#怎么插入图片" class="headerlink" title="怎么插入图片"></a>怎么插入图片</h4><p>这和图床有关系吗。可能这在最基础的算法里面有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Question </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的创建（一）：网站搭建与下载</title>
      <link href="/2023/07/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
      <url>/2023/07/19/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="前言：TRY一个尝试"><a href="#前言：TRY一个尝试" class="headerlink" title="前言：TRY一个尝试"></a>前言：TRY一个尝试</h3><p>在搭建博客之前，我只知道博客是一个“网络上”，“用于记录的”，“网站”。对于搭建博客所需要的时间和知识，我一无所知。依赖于网上的教程，本人于两小时左右搭建了这个网站。<br>这个网站是hexo——github仓库框架。具体搭建方法在网络上已经很详细了。本篇文章只列出原理，流程，和常见问题解答</p><h2 id="Hexo准备"><a href="#Hexo准备" class="headerlink" title="Hexo准备"></a>Hexo准备</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/18/hello-world/"/>
      <url>/2023/07/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index-1.html"/>
      <url>/categories/index-1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>问题</title>
      <link href="/%E9%97%AE%E9%A2%98/index.html"/>
      <url>/%E9%97%AE%E9%A2%98/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
